/*
 * Copyright Â©2025 Ewsgit<https://ewsgit.uk> and YourDash<https://yourdash.ewsgit.uk> contributors.
 * YourDash is licensed under the MIT License. (https://mit.ewsgit.uk)
 */

import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";
import dynamicImport from "vite-plugin-dynamic-import";
import path from "node:path";
import * as fs from "node:fs";
// enable for https testing. import mkcert from "vite-plugin-mkcert"

function applicationRouter() {
  const virtualModuleId = 'virtual:application-router/file';
  // do not follow convention as it makes the virtual file invisible to the ReactJS plugin, leading to .tsx not being recognised as legitimate
  const resolvedVirtualModuleId = /*'\0' + */virtualModuleId;
  const resolvedVirtualModuleIdWithExtension = resolvedVirtualModuleId + '.tsx';

  return {
    name: 'yourdash-application-router-generator', // required, will show up in warnings and errors
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleIdWithExtension;
      }
      return null; // Add return null for non-matching IDs
    },
    load(id: string) {
      if (id === resolvedVirtualModuleIdWithExtension) {
        // Define the template using JSX structure
        let fileTemplate = `/**
 * This file is auto-generated by the applicationRouter plugin.
 * Do not edit this file manually.
 */

import React from "react";
import { Routes, Route } from "react-router-dom";
import loadable from "@loadable/component";

/* loadable_components_placeholder */
const AppRouter = [{/* route_elements_placeholder */}]


export default AppRouter;
`;

        let loadableRegionReplacement = "";
        let routeRegionReplacement = "";
        // Determine apps directory path based on environment variable
        const appsDirectoryPath = process.env.VITE_IS_DOCKER === "true" ? "/web/src/app/apps/" : path.resolve(__dirname, '../../apps/'); // Use path.resolve for relative paths

        let allApps: string[] = [];
        try {
          // Synchronously read the directory content
          allApps = fs.readdirSync(appsDirectoryPath).filter(entry => {
            // Optional: Add filtering to ensure it's a directory or meets criteria
            const entryPath = path.join(appsDirectoryPath, entry);
            try {
              // Check if it's a directory and potentially if the web/src/index.tsx exists
              return fs.statSync(entryPath).isDirectory();
            } catch (statError) {
              console.warn(`[applicationRouter] Could not stat entry: ${entryPath}`, statError);
              return false;
            }
          });
        } catch (err) {
          console.error(`[applicationRouter] Error reading apps directory: ${appsDirectoryPath}`, err);
          // Return an empty router template or throw error depending on desired behavior
          return {
            code: fileTemplate
            .replace("/* loadable_components_placeholder */", "// Error reading apps directory")
             .replace("{/* route_elements_placeholder */}", "{/* Error reading apps directory */}"),
            map: null,
          };
        }


        // Corrected Loop: Iterate through ALL detected apps
        for (let i = 0; i < allApps.length; i++) {
          const appName = allApps[i];
          // Construct the import path reliably
          const appImportPath = path.join(
            path.resolve(appsDirectoryPath, appName), // Get absolute path to app dir
            "./web/src/index.tsx" // Append relative path to component
          ).replaceAll(path.sep, path.posix.sep); // Ensure POSIX separators for import()

          // Generate loadable component definition
          // Added fallback and newline
          loadableRegionReplacement += `const Application${i} = loadable(() => import(/* webpackChunkName: "${appName}" */ "${appImportPath}"), {
  fallback: <div>Loading ${appName}...</div>
});`;

          // Generate JSX Route element
          // Added key prop and newline for readability
          routeRegionReplacement += `<Route key="${appName}" path="${appName}/*" element={<Application${i} />} />,`;
        }

        // Replace placeholders in the template
        fileTemplate = fileTemplate.replace("/* loadable_components_placeholder */", loadableRegionReplacement);
        // Ensure proper indentation for the routes within the JSX
        fileTemplate = fileTemplate.replace("{/* route_elements_placeholder */}", routeRegionReplacement.trimEnd()); // trimEnd to remove trailing newline

        return { code: fileTemplate, map: null, moduleType: 'tsx' };
      }
      return null; // Add return null for non-matching IDs
    }
  };
}


// ViteJS docs: https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    // @ts-ignore
    react({
      babel: {
        plugins: [["babel-plugin-react-compiler", {}]],
      },
    }),
    // @ts-ignore
    dynamicImport(),
    // enable for https tests. mkcert()
    applicationRouter()
  ],
  appType: "spa",
  root: "./",
  base: "./",
  build: {
    rollupOptions: {
      external: ["chart.js"],
    },
    sourcemap: true,
    minify: false,
  },
  css: {
    preprocessorOptions: {
      scss: {
        api: "modern-compiler", // or "modern"
      },
    },
  },
});
